<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>形式検証 on 存在と一意性の証明</title><link>http://forestaa.github.io/blog/tags/%E5%BD%A2%E5%BC%8F%E6%A4%9C%E8%A8%BC/</link><description>Recent content in 形式検証 on 存在と一意性の証明</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 29 Apr 2019 18:38:36 +0900</lastBuildDate><atom:link href="http://forestaa.github.io/blog/tags/%E5%BD%A2%E5%BC%8F%E6%A4%9C%E8%A8%BC/index.xml" rel="self" type="application/rss+xml"/><item><title>LiquidHaskell 入門 その4</title><link>http://forestaa.github.io/blog/posts/liquidhaskell4/</link><pubDate>Mon, 29 Apr 2019 18:38:36 +0900</pubDate><guid>http://forestaa.github.io/blog/posts/liquidhaskell4/</guid><description>&lt;p>&lt;a href="http://forestaa.github.io/blog/blog/posts/liquidhaskell3/">前回の記事&lt;/a>はLiquidHaskellの表現力を高める機能であるAbstract RefinementとBounded Refinementの解説をしました。
今回は&lt;a href="http://forestaa.github.io/blog/blog/posts/liquidhaskell2/">前々回&lt;/a>のナイーブなコードを&lt;strong>Hoareモナド&lt;/strong>を用いてHaskellらしいコードに書き直してみます。
Abstract RefinementとBounded Refinementをガンガン使っていきます。&lt;/p></description></item><item><title>LiquidHaskell 入門 その3</title><link>http://forestaa.github.io/blog/posts/liquidhaskell3/</link><pubDate>Mon, 29 Apr 2019 18:37:53 +0900</pubDate><guid>http://forestaa.github.io/blog/posts/liquidhaskell3/</guid><description>&lt;p>&lt;a href="http://forestaa.github.io/blog/blog/posts/liquidhaskell2/">前回の記事&lt;/a>ではLiquidHaskellを用いて簡単な言語の評価機を作ってみました。
今回はそれをStateモナドを用いて書き直すために必要な新しい機能である&lt;strong>Abstarct Refinement&lt;/strong>, &lt;strong>Bounded Refinmenet&lt;/strong>の解説をしていきたいと思います。&lt;/p></description></item><item><title>LiquidHaskell 入門 その2</title><link>http://forestaa.github.io/blog/posts/liquidhaskell2/</link><pubDate>Fri, 29 Mar 2019 11:30:36 +0900</pubDate><guid>http://forestaa.github.io/blog/posts/liquidhaskell2/</guid><description>&lt;p>&lt;a href="http://forestaa.github.io/blog/blog/posts/liquidhaskell1/">前回の記事&lt;/a>ではLiquidHaskellの基礎を学びました。
今回はLiquidHaskellを用いて、とあるデータ型に対して、通常のHaskellの型の上に、実装者の暗黙の意図を反映したより細かい型をつけてみたいと思います。&lt;/p></description></item><item><title>LiquidHaskell 入門 その1</title><link>http://forestaa.github.io/blog/posts/liquidhaskell1/</link><pubDate>Fri, 22 Mar 2019 15:53:19 +0900</pubDate><guid>http://forestaa.github.io/blog/posts/liquidhaskell1/</guid><description>&lt;p>今回から何回かに分けて &lt;strong>LiquidHaskell&lt;/strong>と&lt;strong>F&lt;/strong>&lt;em>の比較記事を書きたいと思います。
数か月前にいつか触ろうと思っていたLiquidHaskellを試す機会がありました。
やりたかったことがLiquidHaskellだけでは達成できなかったのでF&lt;/em>も試してみました。
その時に見つけた差異を記事にしてみます。
先にネタバレしておくと、HoareモナドはLiquidHaskellではできない?けどF*なら当たり前のように使えるよねっていう話なので、面白そうと思う方は読んでいただけると嬉しいです。
今回の記事では、LiquidHaskellの基礎をまとめることにします。
Haskellを触ったことがある人なら読める内容にしているつもりです。&lt;/p></description></item></channel></rss>